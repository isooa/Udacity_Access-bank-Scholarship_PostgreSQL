--This is the start of Lesson 3

--NULL means NO DATA

--NULL is a property of the data, not a value

/*NULLs - Expert Tip
There are two common ways in which you are likely to encounter NULLs:

NULLs frequently occur when performing a LEFT or RIGHT JOIN. You saw in the last lesson - when some rows in the left table of a left join are not matched with rows in the right table, those rows will contain some NULL values in the result set.


NULLs can also occur from simply missing data in our database.*/

SELECT COUNT(*)
FROM accounts;

SELECT COUNT(accounts.id)
FROM accounts;

SELECT COUNT(id)
from accounts;

--Count does not consider rows that have NULL VALUES

select sum(poster_qty) from orders;

select sum(standard_qty) from orders;

Select sum(total_amt_usd) from orders;

Select standard_amt_usd+gloss_amt_usd from orders;

select standard_amt_usd/standard_qty from orders
group by standard_amt_usd;

select sum(standard_amt_usd)/sum(standard_qty)
from orders;

/*Expert Tip
Functionally, MIN and MAX are similar to COUNT in that they can be used on non-numerical columns. Depending on the column type, MIN will return the lowest number, earliest date, or non-numerical value as early in the alphabet as possible. As you might suspect, MAX does the opposite—it returns the highest number, the latest date, or the non-numerical value closest alphabetically to “Z.”*/

--Experimenting and understanding calculating median

create table grade (
score numeric
);

insert into grade values(55);
insert into grade values(80);
insert into grade values(95);
insert into grade values(100);
insert into grade values(99);
insert into grade values(70);
insert into grade values(60);
insert into grade values (75);

Select * from grade;

-- this is an easy way using offset function, will most likely work odd values
select score from grade order by score offset (select count(*) from grade)/2 limit 1;

--Oracle has a direct median function
Select Median(score) from grade;

--Another way to solve in postgresql
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FROM grade;
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY score) FROM grade;
-- Returning to Udacity exercise

Select * from orders

select min(occurred_at) from orders

select occurred_at from orders
order by occurred_at asc
limit 1;

select max(occurred_at) from orders;

select occurred_at from orders
order by occurred_at desc
limit 1;

SELECT AVG(standard_qty) mean_standard, AVG(gloss_qty) mean_gloss, 
           AVG(poster_qty) mean_poster, AVG(standard_amt_usd) mean_standard_usd, 
           AVG(gloss_amt_usd) mean_gloss_usd, AVG(poster_amt_usd) mean_poster_usd
FROM orders;

SELECT *
FROM (SELECT total_amt_usd
      FROM orders
      ORDER BY total_amt_usd
      LIMIT 3457) AS Table1
ORDER BY total_amt_usd DESC
LIMIT 2;

--Moving to group by

-- Any column in the SELECT statement that is not within an aggregator must be in the GROUP BY clause.

/*GROUP BY - Expert Tip
Before we dive deeper into aggregations using GROUP BY statements, it is worth noting that SQL evaluates the aggregations before the LIMIT clause. If you don’t group by any columns, you’ll get a 1-row result—no problem there. If you group by a column with enough unique values that it exceeds the LIMIT number, the aggregates will be calculated, and then some rows will simply be omitted from the results.

This is actually a nice way to do things because you know you’re going to get the correct aggregates. If SQL cuts the table down to 100 rows, then performed the aggregations, your results would be substantially different. The above query’s results exceed 100 rows, so it’s a perfect example. In the next concept, use the SQL environment to try removing the LIMIT and running it again to see what changes.*/


select a.name, min (o.occurred_at) from
orders o
join accounts a 
on a.id=o.account_id
group by a.name
order by min(occurred_at) asc
limit 1;

-- Note answer

SELECT a.name, o.occurred_at
FROM accounts a
JOIN orders o
ON a.id = o.account_id
ORDER BY occurred_at
LIMIT 1;


select a.name, sum (o.total_amt_usd) from
orders o
join accounts a 
on a.id=o.account_id
group by a.name
order by sum(o.total_amt_usd);

--Note answer
SELECT a.name, SUM(total_amt_usd) total_sales
FROM orders o
JOIN accounts a
ON a.id = o.account_id
GROUP BY a.name;







select a.name, w.channel, max(w.occurred_at) 
from web_events w
join accounts a 
on a.id=w.account_id
group by w.channel,a.name
order by max(w.occurred_at)
limit 1;

--Note Answer

SELECT w.occurred_at, w.channel, a.name
FROM web_events w
JOIN accounts a
ON w.account_id = a.id 
ORDER BY w.occurred_at DESC
LIMIT 1;

select channel, count(*) 
from web_events
group by channel;

select a.primary_poc 
from web_events w
join accounts a 
on a.id=w.account_id
group by a.primary_poc
order by min(w.occurred_at)
limit 1;

select a.name, min (o.total_amt_usd) from
orders o
join accounts a 
on a.id=o.account_id
group by a.name
order by min(o.total_amt_usd);

--Note answer

SELECT a.name, MIN(total_amt_usd) smallest_order
FROM accounts a
JOIN orders o
ON a.id = o.account_id
GROUP BY a.name
ORDER BY smallest_order;


select r.name, count(*) from 
sales_reps s
join region r
on r.id=s.region_id
group by r.name
order by count(*);

--Note answer

SELECT r.name, COUNT(*) num_reps
FROM region r
JOIN sales_reps s
ON r.id = s.region_id
GROUP BY r.name
ORDER BY num_reps;

--Multiple Group by

/*GROUP BY - Expert Tips
The order of column names in your GROUP BY clause doesn’t matter—the results will be the same regardless. If we run the same query and reverse the order in the GROUP BY clause, you can see we get the same results.


As with ORDER BY, you can substitute numbers for column names in the GROUP BY clause. It’s generally recommended to do this only when you’re grouping many columns, or if something else is causing the text in the GROUP BY clause to be excessively long.


A reminder here that any column that is not within an aggregation must show up in your GROUP BY statement. If you forget, you will likely get an error. However, in the off chance that your query does work, you might not like the results!*/



select a.name, avg(o.standard_qty), avg(o.gloss_qty), avg(o.poster_qty)
from orders o
join accounts a
on a.id=o.account_id
group by a.name

select a.name, avg(o.standard_amt_usd), avg(o.gloss_amt_usd), avg(o.poster_amt_usd)
from orders o
join accounts a
on a.id=o.account_id
group by a.name

select s.name, w.channel, count(w.channel)
from sales_reps s
join accounts a
on a.sales_rep_id=s.id
join web_events w 
on w.account_id=a.id
group by s.name,w.channel
order by s.name desc, count(w.channel) asc
eb_events w 
on w.account_id=a.id
group by r.name, w.channel

/*DISTINCT - Expert Tip
It’s worth noting that using DISTINCT, particularly in aggregations, can slow your queries down quite a bit.*/


select r.name, w.channel, count(w.channel)
from region r
join sales_reps s
on r.id=s.region_id
join accounts a
on a.sales_rep_id=s.id
join w

select id,standard_amt_usd, gloss_amt_usd, poster_amt_usd, total_amt_usd from orders

select sum(total_amt_usd) from orders
where id between 1 and 5;
select a.id, count(r.name)
from region r
join sales_reps s
on s.region_id=r.id
join accounts a
on a.sales_rep_id=s.id
group by a.id
order by count(r.name) desc

select count(distinct s.name), count(s.name)
from accounts a
join sales_reps s
on s.id=a.sales_rep_id


--Having clause

select * from web_events;
select * from accounts
select * from orders
select * from region
select * from sales_reps;


select s.name, count(*)
from sales_reps s
join accounts a
on s.id= a.sales_rep_id
group by s.name
having count(*)>5;

select a.id, count(*)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
having count(*)>20;

select a.id, count(*)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
order by count(*) desc
limit 1;

select a.id, sum(o.total_amt_usd)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
having sum(o.total_amt_usd) > 30000
order by sum(total_amt_usd) desc

select a.id, sum(o.total_amt_usd)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
having sum(o.total_amt_usd) < 1000
order by sum(total_amt_usd) desc

select a.id, sum(o.total_amt_usd)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
order by sum(total_amt_usd) desc
limit 1

select a.id, sum(o.total_amt_usd)
from accounts a
join orders o
on a.id=o.account_id
group by a.id
order by sum(total_amt_usd) asc
limit 1

select a.id, w.channel, count(*)
from accounts a
join web_events w
on a.id = w.account_id
group by a.id,w.channel
having w.channel = 'facebook'
and count(*)>6
order by count(*) desc;

select a.id, w.channel, count(*)
from accounts a
join web_events w
on a.id = w.account_id
group by a.id,w.channel
having w.channel = 'facebook'
and count(*)>6
order by count(*) desc
limit 1;

select w.channel, count(*)
from accounts a
join web_events w
on a.id = w.account_id
group by w.channel
order by count(*) desc
limit 1;

--Date functions

select date_part ('year', occurred_at), sum(total_amt_usd)
from orders
group by 1
order by 2 desc

select date_part ('month', occurred_at), sum(total_amt_usd)
from orders
WHERE occurred_at BETWEEN '2014-01-01' AND '2017-01-01'
group by 1
order by 2 desc;

select date_part ('year', occurred_at), sum(total)
from orders
group by 1
order by 2 desc;

select date_part ('month', occurred_at), sum(total)
from orders
WHERE occurred_at BETWEEN '2014-01-01' AND '2017-01-01'
group by 1
order by 2 desc;


select a.name, date_trunc ('month', o.occurred_at), sum(o.gloss_amt_usd)
from orders o
join accounts a
on a.id = o.account_id
where a.name = 'Walmart'
group by 1,2
order by 3 desc
limit 1;

--CASE statements

select account_id, total_amt_usd, case when total_amt_usd >=3000 then 'Large' else 'Small' end
from orders
order by 2 desc;

select total, case when total >=2000 then 'at least 2000' when total < 2000 or total >=1000 then 'between 1000 and 2000' else 'Less than 1000' end
from orders
order by 1 asc;






