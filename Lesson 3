--This is the start of Lesson 3

--NULL means NO DATA

--NULL is a property of the data, not a value

/*NULLs - Expert Tip
There are two common ways in which you are likely to encounter NULLs:

NULLs frequently occur when performing a LEFT or RIGHT JOIN. You saw in the last lesson - when some rows in the left table of a left join are not matched with rows in the right table, those rows will contain some NULL values in the result set.


NULLs can also occur from simply missing data in our database.*/

SELECT COUNT(*)
FROM accounts;

SELECT COUNT(accounts.id)
FROM accounts;

SELECT COUNT(id)
from accounts;

--Count does not consider rows that have NULL VALUES

select sum(poster_qty) from orders;

select sum(standard_qty) from orders;

Select sum(total_amt_usd) from orders;

Select standard_amt_usd+gloss_amt_usd from orders;

select standard_amt_usd/standard_qty from orders
group by standard_amt_usd;

select sum(standard_amt_usd)/sum(standard_qty)
from orders;

/*Expert Tip
Functionally, MIN and MAX are similar to COUNT in that they can be used on non-numerical columns. Depending on the column type, MIN will return the lowest number, earliest date, or non-numerical value as early in the alphabet as possible. As you might suspect, MAX does the opposite—it returns the highest number, the latest date, or the non-numerical value closest alphabetically to “Z.”*/

--Experimenting and understanding calculating median

create table grade (
score numeric
);

insert into grade values(55);
insert into grade values(80);
insert into grade values(95);
insert into grade values(100);
insert into grade values(99);
insert into grade values(70);
insert into grade values(60);
insert into grade values (75);

Select * from grade;

-- this is an easy way using offset function, will most likely work odd values
select score from grade order by score offset (select count(*) from grade)/2 limit 1;

--Oracle has a direct median function
Select Median(score) from grade;

--Another way to solve in postgresql
SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY score) FROM grade;
SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY score) FROM grade;
-- Returning to Udacity exercise

Select * from orders

select min(occurred_at) from orders

select occurred_at from orders
order by occurred_at asc
limit 1;

select max(occurred_at) from orders;

select occurred_at from orders
order by occurred_at desc
limit 1;

SELECT AVG(standard_qty) mean_standard, AVG(gloss_qty) mean_gloss, 
           AVG(poster_qty) mean_poster, AVG(standard_amt_usd) mean_standard_usd, 
           AVG(gloss_amt_usd) mean_gloss_usd, AVG(poster_amt_usd) mean_poster_usd
FROM orders;

SELECT *
FROM (SELECT total_amt_usd
      FROM orders
      ORDER BY total_amt_usd
      LIMIT 3457) AS Table1
ORDER BY total_amt_usd DESC
LIMIT 2;

--Moving to group by

-- Any column in the SELECT statement that is not within an aggregator must be in the GROUP BY clause.

/*GROUP BY - Expert Tip
Before we dive deeper into aggregations using GROUP BY statements, it is worth noting that SQL evaluates the aggregations before the LIMIT clause. If you don’t group by any columns, you’ll get a 1-row result—no problem there. If you group by a column with enough unique values that it exceeds the LIMIT number, the aggregates will be calculated, and then some rows will simply be omitted from the results.

This is actually a nice way to do things because you know you’re going to get the correct aggregates. If SQL cuts the table down to 100 rows, then performed the aggregations, your results would be substantially different. The above query’s results exceed 100 rows, so it’s a perfect example. In the next concept, use the SQL environment to try removing the LIMIT and running it again to see what changes.*/


select a.name, min (o.occurred_at) from
orders o
join accounts a 
on a.id=o.account_id
group by a.name
order by min(occurred_at) asc
limit 1;

select a.name, sum (o.total_amt_usd) from
orders o
join accounts a 
on a.id=o.account_id
group by a.name
order by sum(o.total_amt_usd);
